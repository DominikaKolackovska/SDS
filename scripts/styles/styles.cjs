const fs = require("fs");

// run with node --env-file=.env figma-styles.cjs
// const TOKEN = process.env.FIGMA_ACCESS_TOKEN;
const WRITE_DIR = "../../src";

go();

async function go() {
  const json = JSON.parse(fs.readFileSync("./styles.json"));
  const effectDefs = [];
  const text = [];
  json.forEach(({ type, ...style }) => {
    if (type === "TEXT") {
      const {
        name,
        fontSize,
        textDecoration,
        fontName,
        letterSpacing,
        lineHeight,
        variables,
      } = style;

      const fontStyle = fontName.style.match(/Italic/i) ? "italic" : "normal";
      const css = [
        fontStyle,
        tokenFromFontWeight(fontName.style),
        `${tokenFromFontSize(fontSize)}`,
        tokenFromFontFamily(fontName.family),
      ].join(" ");
      text.push(
        `  --sds-font-${name
          .replace(/^[^a-zA-Z0-9]+/, "")
          .replace(/[^a-zA-Z0-9]+/g, "-")
          .toLowerCase()}: ${css};`,
      );
    } else if (type === "EFFECT") {
      const { name, effects } = style;
      const shadows = [];
      const filters = [];
      const backdropFilters = [];
      effects.forEach((effect) => {
        if (effect.visible) {
          if (effect.type.match("SHADOW")) {
            shadows.push(formatEffect(effect));
          }
          if (effect.type.match("LAYER_BLUR")) {
            filters.push(formatEffect(effect));
          }
          if (effect.type.match("BACKGROUND_BLUR")) {
            backdropFilters.push(formatEffect(effect));
          }
        }
      });
      if (shadows.length) {
        effectDefs.push(
          `${tokenFromName("effects-shadows-" + name)}: ${shadows.join(", ")}`,
        );
      }
      if (filters.length) {
        effectDefs.push(
          `${tokenFromName("effects-filter-" + name)}: ${filters[0]}`,
        );
      }
      if (backdropFilters.length) {
        effectDefs.push(
          `${tokenFromName("effects-backdrop-filter-" + name)}: ${backdropFilters[0]}`,
        );
      }
    }
  });
  fs.writeFileSync(
    `${WRITE_DIR}/theme-font.css`,
    `/* 
* This file is automatically generated by styles.cjs! 
*/

:root {\n${text.join("\n")}\n}`,
  );
  fs.writeFileSync(
    `${WRITE_DIR}/theme-effects.css`,
    `/* 
* This file is automatically generated by styles.cjs! 
*/

:root {\n  ${effectDefs.join(";\n  ")};\n}`,
  );
  console.log("DONE!");
}

function tokenFromName(name) {
  return `--sds-${name
    .split(/[^a-zA-Z0-9]+/)
    .join("-")
    .toLowerCase()
    .replace("font-font", "font")}`;
}

function tokenFromFontFamily(family) {
  return (
    {
      "Roboto Mono": "var(--sds-typography-family-mono)",
      Inter: "var(--sds-typography-family-sans)",
      "Noto Serif": "var(--sds-typography-family-serif)",
    }[family] || family
  );
}

function tokenFromFontSize(int) {
  return (
    {
      "0.750": "var(--sds-typography-scale-01)",
      0.875: "var(--sds-typography-scale-02)",
      "1.000": "var(--sds-typography-scale-03)",
      "1.250": "var(--sds-typography-scale-04)",
      "1.500": "var(--sds-typography-scale-05)",
      "2.000": "var(--sds-typography-scale-06)",
      "2.500": "var(--sds-typography-scale-07)",
      "3.000": "var(--sds-typography-scale-08)",
      "4.000": "var(--sds-typography-scale-09)",
      "4.500": "var(--sds-typography-scale-10)",
    }[(int / 16).toFixed(3)] || int / 16 + "rem"
  );
}

function tokenFromFontWeight(style) {
  let fontWeight;
  const weights = {
    Thin: "var(--sds-typography-weight-thin)",
    "Extra Light": "var(--sds-typography-weight-extra-light)",
    Light: "var(--sds-typography-weight-light)",
    Normal: "var(--sds-typography-weight-regular)",
    Regular: "var(--sds-typography-weight-regular)",
    Medium: "var(--sds-typography-weight-medium)",
    Semi: "var(--sds-typography-weight-semi-bold)",
    Demi: "var(--sds-typography-weight-semi-bold)",
    Bold: "var(--sds-typography-weight-bold)",
    "Extra Bold": "var(--sds-typography-weight-extra-bold)",
    Black: "var(--sds-typography-weight-black)",
    Heavy: "var(--sds-typography-weight-black)",
  };

  for (let weight in weights) {
    if (style.match(new RegExp(weight.split(" ").join(" ?")))) {
      fontWeight = weights[weight];
    }
  }

  if (!fontWeight) {
    fontWeight = style === "Italic" ? weights.Normal : "unknown";
  }

  return fontWeight;
}

function primitiveFromInt(int) {
  const found = {
    0: "var(--sds-primitives-0)",
    1: "var(--sds-primitives-1)",
    10: "var(--sds-primitives-10)",
    104: "var(--sds-primitives-104)",
    112: "var(--sds-primitives-112)",
    12: "var(--sds-primitives-12)",
    120: "var(--sds-primitives-120)",
    128: "var(--sds-primitives-128)",
    14: "var(--sds-primitives-14)",
    144: "var(--sds-primitives-144)",
    16: "var(--sds-primitives-16)",
    160: "var(--sds-primitives-160)",
    18: "var(--sds-primitives-18)",
    184: "var(--sds-primitives-184)",
    2: "var(--sds-primitives-2)",
    20: "var(--sds-primitives-20)",
    200: "var(--sds-primitives-200)",
    224: "var(--sds-primitives-224)",
    24: "var(--sds-primitives-24)",
    240: "var(--sds-primitives-240)",
    256: "var(--sds-primitives-256)",
    28: "var(--sds-primitives-28)",
    288: "var(--sds-primitives-288)",
    3: "var(--sds-primitives-3)",
    32: "var(--sds-primitives-32)",
    320: "var(--sds-primitives-320)",
    36: "var(--sds-primitives-36)",
    360: "var(--sds-primitives-360)",
    4: "var(--sds-primitives-4)",
    40: "var(--sds-primitives-40)",
    44: "var(--sds-primitives-44)",
    48: "var(--sds-primitives-48)",
    5: "var(--sds-primitives-5)",
    56: "var(--sds-primitives-56)",
    6: "var(--sds-primitives-6)",
    64: "var(--sds-primitives-64)",
    7: "var(--sds-primitives-7)",
    72: "var(--sds-primitives-72)",
    8: "var(--sds-primitives-8)",
    80: "var(--sds-primitives-80)",
    88: "var(--sds-primitives-88)",
    9: "var(--sds-primitives-9)",
    96: "var(--sds-primitives-96)",
  }[int.toString().replace("-", "")];
  if (found) {
    return int.toString().match("-") ? `calc(-1 * ${found})` : found;
  }
  return int / 16 + "rem";
}

function formatEffect({ type, ...effect }) {
  if (type === "DROP_SHADOW" || type === "INNER_SHADOW") {
    const {
      radius,
      offset: { x, y },
      spread,
      hex,
      variables,
    } = effect;
    const numbers = [
      variables.offsetX
        ? `var(${tokenFromName("size-" + variables.offsetX)})`
        : primitiveFromInt(x),
      variables.offsetY
        ? `var(${tokenFromName("size-" + variables.offsetY)})`
        : primitiveFromInt(y),
      variables.radius
        ? `var(${tokenFromName("size-" + variables.radius)})`
        : primitiveFromInt(radius),
      variables.spread
        ? `var(${tokenFromName("size-" + variables.spread)})`
        : primitiveFromInt(spread),
      variables.color
        ? `var(${tokenFromName("color-" + variables.color)})`
        : hex,
    ];
    return `${type === "INNER_SHADOW" ? "inset " : ""}${numbers.join(" ")}`;
  }
}
