import fs from "fs";
import { getFileStyles, getFileVariables } from "./fromFigma.mjs";

const JOIN_CHAR = "";
const CONVERT_TO_REM = true;
const NAMESPACE = "org.sds";
const TOKEN_PREFIX = "sds-";

const SKIP_REST_API = process.argv.includes("--skip-rest-api");
const WRITE_DIR = "../../src";

const COLOR_THEMES = ["light", "purple_light", "blue_light", "teal_light"];
const COLOR_THEMES_DARK = ["dark", "purple_dark", "blue_dark", "teal_dark"];
// stripped from mode names above in theme class names
const COLOR_THEME_LIGHT_REMOVE = "_light";
const COLOR_THEME_DARK_REMOVE = "_dark";
const RESPONSIVE_SIZE_ORDER = ["mobile", "tablet", "desktop"];
const RESPONSIVE_SIZE_TOKEN_SUFFIX = "width-device-min";
const _FILE_KEY = "YfiqA0yWMXuLJAzkZNpBdy";
const FILE_KEY = "J0KLPKXiONDRssXD1AX9Oi";

// const formatters = {
//   "weight-black-italic": "style",
// };

initialize();

async function initialize() {
  if (!SKIP_REST_API) {
    const stylesJSON = await getFileStyles(FILE_KEY);
    fs.writeFileSync("./styles.json", JSON.stringify(stylesJSON, null, 2));
    const tokensJSON = await getFileVariables(FILE_KEY, NAMESPACE);
    fs.writeFileSync("./tokens.json", JSON.stringify(tokensJSON, null, 2));
  }
  const { processed, themeCSS } = processTokenJSON(
    JSON.parse(fs.readFileSync("./tokens.json")),
  );
  const variableLookups = [
    ...Object.values(processed.typography.primitive)[0],
    ...Object.values(processed.typography.main)[0],
    ...Object.values(processed.color.primitive)[0],
    ...Object.values(processed.color.main)[0],
    ...Object.values(processed.size.main)[0],
  ].reduce((into, item) => {
    into[item.figmaId] = item;
    return into;
  }, {});

  const stylesCSS = await processStyleJSON(
    JSON.parse(fs.readFileSync("./styles.json")),
    variableLookups,
  );

  fs.writeFileSync(
    `${WRITE_DIR}/theme.css`,
    [...themeCSS, ...stylesCSS].join("\n"),
  );
  console.log("Done!");
}

function processTokenJSON(data) {
  const processed = {
    color: {
      primitive: {},
      main: {},
      colorSchemes: COLOR_THEMES,
      colorSchemesDark: COLOR_THEMES_DARK,
    },
    size: { main: {} },
    typography: { primitive: {}, main: {} },
    responsive: {
      main: {},
      responsiveSizeOrder: RESPONSIVE_SIZE_ORDER,
      responsiveSizeTokenSuffix: RESPONSIVE_SIZE_TOKEN_SUFFIX,
    },
  };

  processCollection(data, processed.color, "@colors", {
    primitiveKey: "@color_primitives",
    prefix: "color",
  });
  processCollection(data, processed.typography, "@typography", {
    prefix: "typography",
    primitiveKey: "@typography_primitives",
    convertPixelToRem: true,
  });
  processCollection(data, processed.responsive, "@responsive", {
    prefix: "responsive",
    convertPixelToRem: false,
  });
  processCollection(data, processed.size, "@size", {
    prefix: "size",
    convertPixelToRem: true,
  });

  const fileStringCSSLines = [
    "/*",
    " * This file is automatically generated by tokens.cjs!",
    " */",
  ];
  for (let key in processed) {
    fileStringCSSLines.push(
      ...fileStringCSSFromProcessedObject(processed[key], key),
    );
  }

  /* 
In the future, themeing will be handled via @container style() queries

:root {
  --theme: default; // blue, purple, teal
}

@container style(--theme: default) {
  :root {}
  @media (prefers-color-scheme: dark) {
    :root {}
  }
}
*/

  function fileStringCSSFromProcessedObject(
    {
      primitive,
      main,
      colorSchemes,
      colorSchemesDark,
      responsiveSizeOrder,
      responsiveSizeTokenSuffix,
    },
    key,
  ) {
    const lines = [];
    if (primitive) {
      const values = Object.values(primitive)[0];
      lines.push(
        ...[
          `/* ${key}: primitive */`,
          ":root {",
          drawCSSPropLines(values, "  "),
          "}",
        ],
      );
    }
    if (colorSchemes) {
      colorSchemes.forEach((scheme, i) => {
        if (i === 0) {
          lines.push(...[`/* ${key}: ${scheme} (default) */`, ":root {"]);
        } else {
          lines.push(
            ...[
              `/* ${key}: ${scheme} */`,
              `.${TOKEN_PREFIX}scheme-${key}-${scheme.replace(COLOR_THEME_LIGHT_REMOVE, "")} {`,
            ],
          );
        }
        lines.push(drawCSSPropLines(main[scheme], "  "), "}");
      });
      if (colorSchemesDark) {
        lines.push("@media (prefers-color-scheme: dark) {");
        colorSchemesDark.forEach((scheme, i) => {
          if (i === 0) {
            lines.push(...[`  /* ${key}: ${scheme} (default) */`, "  :root {"]);
          } else {
            lines.push(
              ...[
                `  /* ${key}: ${scheme} */`,
                `  .${TOKEN_PREFIX}scheme-${key}-${scheme.replace(COLOR_THEME_DARK_REMOVE, "")} {`,
              ],
            );
          }
          lines.push(drawCSSPropLines(main[scheme], "    "), "  }");
        });
        lines.push("}");
      }
    } else if (responsiveSizeOrder) {
      const regexp = new RegExp(`${responsiveSizeTokenSuffix}$`, "g");
      const sizes = responsiveSizeOrder.map((size) => {
        const found = main[size].find(({ property }) =>
          Boolean(property.match(regexp)),
        );
        return found ? found.value : "9999999px";
      });
      responsiveSizeOrder.forEach((size, i) => {
        if (i === 0) {
          lines.push(
            ...[
              `/* ${key}: ${size} (default) */`,
              ":root {",
              drawCSSPropLines(main[size], "  "),
              "}",
            ],
          );
        } else {
          lines.push(
            ...[
              `/* ${key}: ${size} */`,
              `@media (min-width: ${sizes[i]}) {`,
              "  :root {",
              drawCSSPropLines(main[size], "    "),
              "  }",
              "}",
            ],
          );
        }
      });
    } else {
      // main only
      if (main.length === 1) {
        const values = Object.values(main)[0];
        lines.push(...[":root {", drawCSSPropLines(values, "  "), "}"]);
      } else {
        let first;
        for (let k in main) {
          if (!first) {
            first = true;
            lines.push(...[`/* ${key}: ${k} (default) */`, ":root {"]);
          } else {
            lines.push(
              ...[`/* ${key}: ${k} */`, `.${TOKEN_PREFIX}theme-${key}-${k} {`],
            );
          }
          lines.push(...[drawCSSPropLines(main[k], "  "), "}"]);
        }
      }
    }
    return lines;
  }

  const codeSyntaxArrayString = `Promise.all([
    ${drawCodeSyntaxWeb(processed.responsive.main.mobile)},
    ${drawCodeSyntaxWeb(processed.size.main.default)},
    ${drawCodeSyntaxWeb(processed.typography.main.default)},
    ${drawCodeSyntaxWeb(processed.color.primitive.value)},
    ${drawCodeSyntaxWeb(processed.color.main.light)}
    ].map(async ([variableId, webSyntax]) => {
      const variable = await figma.variables.getVariableByIdAsync(variableId);
      if (variable) variable.setVariableCodeSyntax("WEB", webSyntax);
      return;
    })).then(() => console.log("DONE!")).catch(console.error)`;

  fs.writeFileSync("./tokensCodeSyntaxes.js", codeSyntaxArrayString);

  return { processed, themeCSS: fileStringCSSLines };

  function drawCSSPropDefinition(lines, indent = "  ") {
    return lines
      .sort()
      .map((l) => {
        let type = ["fontWeight", "number"].includes(l.type)
          ? "number"
          : l.type === "color"
            ? "color"
            : "*";
        return `${indent}@property ${l.property} {
  ${indent}  syntax: "${type === "*" ? "*" : `<${type}>`}";
  ${indent}  inherits: true;
  ${indent}  initial-value: ${type === "color" ? "#000000" : type === "number" ? 0 : l.type};
  ${indent}}`;
      })
      .join("\n\n");
  }

  function drawCSSPropLines(lines = [], indent = "  ") {
    return (
      lines
        .sort((a, b) => (a.property > b.property ? 1 : -1))
        .map((l) => `${indent}${l.property}: ${l.value}`)
        .join(";\n") + ";"
    );
  }

  function drawCodeSyntaxWeb(lines = []) {
    return lines
      .sort((a, b) => (a.property > b.property ? 1 : -1))
      .map((l) => `["${l.figmaId}", "var(${l.property})"]`)
      .join(",\n");
  }

  function processCollection(
    data,
    processed,
    mainKey,
    {
      primitiveKey = "",
      convertPixelToRem = CONVERT_TO_REM,
      prefix,
      removeFromLastKey = [],
    },
  ) {
    const fullPrefix = `${TOKEN_PREFIX}${prefix}`;
    if (processed.primitive && primitiveKey) {
      traverse(
        processed.primitive,
        data[primitiveKey],
        primitiveKey,
        mainKey,
        fullPrefix,
        convertPixelToRem,
        removeFromLastKey,
        "",
        fullPrefix ? [fullPrefix] : undefined,
      );
    }
    traverse(
      processed.main,
      data[mainKey],
      primitiveKey || mainKey,
      mainKey,
      fullPrefix,
      convertPixelToRem,
      removeFromLastKey,
      "",
      fullPrefix ? [fullPrefix] : undefined,
    );
  }

  function traverse(
    definitions,
    object,
    primitiveKey,
    mainKey,
    prefix,
    convertPixelToRem = CONVERT_TO_REM,
    removeFromLastKey = [],
    currentType = "",
    keys = [],
  ) {
    const lastKey = keys[keys.length - 1];
    if (lastKey) {
      removeFromLastKey.forEach((a) => {
        keys[keys.length - 1] = keys[keys.length - 1].replace(a, "");
      });
    }
    const property = `--${keys.join("-")}`;
    const propertyNameFull = keys
      .map((key) =>
        key
          .split(/[^\dA-Za-z]/)
          .map((k) => `${k.charAt(0).toUpperCase()}${k.slice(1)}`)
          .join(""),
      )
      .join("");
    // .replace(/^color/i, "");
    const propertyName =
      propertyNameFull.charAt(0).toLowerCase() + propertyNameFull.slice(1);
    const type = object.$type || currentType;
    if ("$value" in object) {
      if ("$extensions" in object && NAMESPACE in object.$extensions) {
        const figmaId = object.$extensions[NAMESPACE].figmaId;
        for (let mode in object.$extensions[NAMESPACE].modes) {
          definitions[mode] = definitions[mode] || [];
          definitions[mode].push({
            property,
            propertyName,
            figmaId,
            value: valueToCSS(
              property,
              object.$extensions[NAMESPACE].modes[mode],
              primitiveKey,
              mainKey,
              convertPixelToRem,
              prefix,
            ),
            type,
          });
        }
      } else {
        const figmaId =
          "$extensions" in object && NAMESPACE in object.$extensions
            ? object.$extensions[NAMESPACE].figmaId
            : "UNDEFINED";
        const mode = "default";
        definitions[mode] = definitions[mode] || [];
        definitions[mode].push({
          property,
          propertyName,
          figmaId,
          value: valueToCSS(
            property,
            object.$value,
            primitiveKey,
            mainKey,
            convertPixelToRem,
            "",
          ),
          type,
        });
      }
    } else {
      Object.entries(object).forEach(([key, value]) => {
        if (key.charAt(0) !== "$") {
          traverse(
            definitions,
            value,
            primitiveKey,
            mainKey,
            prefix,
            convertPixelToRem,
            removeFromLastKey,
            type,
            [...keys, key],
          );
        }
      });
    }
  }

  function valueToCSS(
    property,
    value,
    primitiveKey,
    mainKey,
    convertPixelToRem,
    prefix = "",
  ) {
    if (value.toString().charAt(0) === "{")
      return `var(--${value
        .replace(`${primitiveKey}${JOIN_CHAR}`, prefix)
        .replace(`${mainKey}${JOIN_CHAR}`, prefix)
        .replace(/[\. ]/g, "-")
        .replace(/^\{/, "")
        .replace(/\}$/, "")})`;
    const valueIsDigits = value.toString().match(/^-?\d+$/);
    const isRatio = property.match(/(ratio-)/);
    const isNumeric =
      valueIsDigits && !property.match(/(weight|ratio-)/) && !isRatio;
    if (isNumeric) {
      return convertPixelToRem ? `${parseInt(value) / 16}rem` : `${value}px`;
    } else if (isRatio) {
      return Math.round(value * 10000) / 10000;
    }
    if (property.match("family-mono")) {
      return `"${value}", monospace`;
    } else if (property.match("family-sans")) {
      return `"${value}", sans-serif`;
    } else if (property.match("family-serif")) {
      return `"${value}", serif`;
    }
    return value;
  }
}

async function processStyleJSON(data, variablesLookup) {
  const effectDefs = [];
  const text = [];
  data.forEach(({ type, ...style }) => {
    if (type === "TEXT") {
      const {
        name,
        fontSize,
        fontFamily,
        fontWeight,
        fontStyle = "normal",
      } = style;

      const css = [
        valueFromPossibleVariable(fontStyle),
        valueFromPossibleVariable(fontWeight),
        valueFromPossibleVariable(fontSize),
        valueFromPossibleVariable(fontFamily),
      ].join(" ");
      text.push(
        `--${TOKEN_PREFIX}font-${name
          .replace(/^[^a-zA-Z0-9]+/, "")
          .replace(/[^a-zA-Z0-9]+/g, "-")
          .toLowerCase()}: ${css};`,
      );
    } else if (type === "EFFECT") {
      const { name, effects } = style;
      const shadows = [];
      const filters = [];
      const backdropFilters = [];
      effects.forEach((effect) => {
        if (effect.visible) {
          if (effect.type.match("SHADOW")) {
            shadows.push(formatEffect(effect));
          }
          if (effect.type.match("LAYER_BLUR")) {
            filters.push(formatEffect(effect));
          }
          if (effect.type.match("BACKGROUND_BLUR")) {
            backdropFilters.push(formatEffect(effect));
          }
        }
      });
      if (shadows.length) {
        effectDefs.push(
          `--${TOKEN_PREFIX}effects-shadows-${name}: ${shadows.join(", ")};`,
        );
      }
      if (filters.length) {
        effectDefs.push(
          `--${TOKEN_PREFIX}effects-filter-${name}: ${filters[0]};`,
        );
      }
      if (backdropFilters.length) {
        effectDefs.push(
          `--${TOKEN_PREFIX}effects-backdrop-filter-${name}: ${backdropFilters[0]};`,
        );
      }
    }
  });

  return [
    "/* styles */",
    ":root {",
    "  " + [...text, ...effectDefs].join("\n  "),
    "}",
  ];

  function valueFromPossibleVariable(item = "") {
    if (typeof item === "object") {
      // attempting to find bound variables
      const variable = variablesLookup[item.id];
      return variable ? `var(${variable.property})` : JSON.stringify(item);
    } else if (item.match(/^[1-9]00$/)) {
      // attempting to find variable for weights
      // the scenario where style is used so weight is int
      const variable = variablesLookup.find(({ value }) => value === item);
      return variable ? `var(${variable.property})` : item;
    }
    return item;
  }

  function formatEffect({ type, ...effect }) {
    if (type === "DROP_SHADOW" || type === "INNER_SHADOW") {
      const {
        radius,
        offset: { x, y },
        spread,
        hex,
        boundVariables,
      } = effect;
      const numbers = [
        boundVariables.offsetX
          ? valueFromPossibleVariable(boundVariables.offsetX)
          : x,
        boundVariables.offsetY
          ? valueFromPossibleVariable(boundVariables.offsetY)
          : y,
        boundVariables.radius
          ? valueFromPossibleVariable(boundVariables.radius)
          : radius,
        boundVariables.spread
          ? valueFromPossibleVariable(boundVariables.spread)
          : spread,
        boundVariables.color
          ? valueFromPossibleVariable(boundVariables.color)
          : hex,
      ];
      return `${type === "INNER_SHADOW" ? "inset " : ""}${numbers.join(" ")}`;
    }
  }
}
